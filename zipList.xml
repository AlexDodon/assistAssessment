<problem>
<text>
Write a function [[function]] which takes as arguments 2 lists and zips them. For example, [[callExample]] must definitely return [[exampleResult]].
</text>
<example language="Python">
myZip([1,2,3],["a","b","c"])
</example>
<solution language="Python">
def myZip(a,b):
    return list(zip(a,b))
</solution>
<tests language="Python">
myZip(["a","b","c"],[1,2,4])
myZip([1,2,3],["a","b","c"])
myZip([1,2,3],[1,2,3])
</tests>
<example language="Haskell">
myZip [1,2,3] ["a","b","c"]
</example>
<solution language="Haskell">
myZip::[a] -> [b] -> [(a,b)]
myZip = zip
</solution>
<tests language="Haskell">
myZip ["a","b","c"] [1,2,3]
myZip [1,2,3] ["a","b","c"]
myZip [1,2,3] [1,2,3]
</tests>
<example language="CommonLisp">
(myZip '(a b c) '(1 2 3))
</example>
<solution language="CommonLisp">
(defun myZip (a b)
  (mapcar #'list a b ))
</solution>
<tests language="CommonLisp">
(myZip '(a b c) '(1 2 3))
(myZip '(1 2 3) '(1 2 3))
(myZip '(1 2 3) '(a b c))
</tests>
<example language="PolyML">
myZip ([1,2,3], ["a","b","c"])
</example>
<solution language="PolyML">
fun myZip [] [] = []
  | myZip (x::xs) (y::ys) = (x,y)::(myZip (xs,ys))
</solution>
<tests language="PolyML">
myZip (["a","b","c"], [1,2,3])
myZip ([1,2,3], ["a","b","c"])
myZip ([1,2,3], [1,2,3])
</tests>
</problem> 
